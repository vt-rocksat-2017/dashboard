#!/usr/bin/env python
from math import *
import string
import time
import sys
import csv
import os
from datetime import datetime as date
import numpy as np

deg2rad = pi / 180.0
rad2deg = 180.0 / pi
c       = float(299792458)  #[m/s], speed of light
R_e     = 6378.137 				#Earth Radius, in kilometers
e_e     = 0.081819221456	    #Eccentricity of Earth

class measurements(object):
    def __init__(self):
        self.time_rx    = []  #Received datetime UTC timestamp from local computer
        self.rx_offset  = []  #Receive offset in seconds from launch
        self.callsign   = None       #Callsign
        self.pkt_id     = []  #number of packets generated by transmitter, dupes WILL happen
        self.time_tx    = []  #time from tx activation
        self.temp       = []  #Celsius
        self.pres       = []  #millibar
        self.alt_ft     = []  #Altitude computed from pressure, in feet
        self.alt_m      = []  #Altitude computed from pressure, in meters
        self.yaw        = []  #yaw, degrees
        self.pitch      = []  #pitch, degrees
        self.roll       = []  #roll, degrees
        self.x_accel    = []  #X-Axis Accelerometer, g
        self.y_accel    = []  #Y-Axis Accelerometer, g
        self.z_accel    = []  #Z-Axis Accelerometer, g

    def append(self, data, ts, rx_offset):
        self.time_rx.append(ts)             #Received datetime UTC timestamp from local computer
        self.rx_offset.append(rx_offset)
        self.callsign = data[1]             #Callsign
        self.pkt_id.append(int(data[2]))    #number of packets generated by transmitter, dupes WILL happen
        self.time_tx.append(float(data[3])) #time from tx activation
        self.temp.append(float(data[4]))    #Celsius
        self.pres.append(float(data[5]))#millibar
        alt_ft, alt_m = pressureToAltitude(float(data[5]))
        self.alt_ft.append(alt_ft)          #Altitude computed from pressure, in feet
        self.alt_m.append(alt_m)            #Altitude computed from pressure, in meters
        self.yaw.append(float(data[6]))     #yaw, degrees
        self.pitch.append(float(data[7]))   #pitch, degrees
        self.roll.append(float(data[8]))    #roll, degrees
        self.x_accel.append(float(data[9])) #X-Axis Accelerometer, g
        self.y_accel.append(float(data[10]))#Y-Axis Accelerometer, g
        self.z_accel.append(float(data[11]))#Z-Axis Accelerometer, g

    def get_last_data(self):
        a = self.time_rx[-1:][0]
        b = self.callsign
        c = self.pkt_id[-1:][0]
        d = self.time_tx[-1:][0]
        e = self.temp[-1:][0]
        f = self.pres[-1:][0]
        g = self.alt_ft[-1:][0]
        h = self.alt_m[-1:][0]
        i = self.yaw[-1:][0]
        j = self.pitch[-1:][0]
        k = self.roll[-1:][0]
        l = self.x_accel[-1:][0]
        m = self.y_accel[-1:][0]
        n = self.z_accel[-1:][0]
        o = self.rx_offset[-1]
        return [a,b,c,d,e,f,g,h,i,j,k,l,m,n,o]

class faults(object):
    def __init__(self):
        self.time_rx    = []            #Received datetime UTC timestamp from local computer
        self.callsign   = None
        self.fault_flag = []
        self.count      = []
        self.time_tx    = []
        self.error_code = []

    def append(self, data, ts):
        self.time_rx.append(ts)         #Received datetime UTC timestamp from local computer
        self.callsign = data[1]
        self.fault_flag.append(data[2])
        self.count.append(data[3])
        self.time_tx.append(data[4])
        self.error_code.append(data[5])

class recons(object):
    def __init__(self):
        self.time_rx    = []    #Received datetime UTC timestamp from local computer
        self.callsign   = None
        self.fault_flag = []
        self.ser_port   = []
        self.time_tx    = []

    def append(self, data, ts):
        self.time_rx.append(ts)    #Received datetime UTC timestamp from local computer
        self.callsign = data[1]    
        self.fault_flag.append(data[2])
        self.ser_port.append(data[3])
        self.time_tx.append(data[4])

def pressureToAltitude(p):
    #p = pressure in mbar
    alt_ft = (1-(p/1013.25)**0.190284)*145366.45
    alt_m  = alt_ft * 0.3048
    return alt_ft, alt_m

#--Range Calculations Functions------
def LLH_To_ECEF(lat, lon, h):
	#INPUT:
	#	h   - height above ellipsoid (MSL), km
	#	lat - geodetic latitude, in radians
	#	lon - longitude, in radians
    C_e = R_e / sqrt(1 - pow(e_e, 2) * pow(sin(lat),2))
    S_e = C_e * (1 - pow(e_e, 2))
    r_i = (C_e + h) * cos(lat) * cos(lon)
    r_j = (C_e + h) * cos(lat) * sin(lon)
    r_k = (S_e + h) * sin(lat)
    return r_i, r_j, r_k

def RAZEL(lat1, lon1, h1, lat2, lon2, h2):
	#Calculates Range, Azimuth, Elevation in SEZ coordinate frame from SITE to UAV
	#INPUT:
	# lat1, lon1, h1 - Site Location
	# lat2, lon2, h2 - UAV location
    # lats and lons in degrees
    # h in km
	#OUTPUT:
	# Slant Range, Azimuth, Elevation

    lat1 = lat1 * deg2rad
    lon1 = lon1 * deg2rad
    lat2 = lat2 * deg2rad
    lon2 = lon2 * deg2rad
    
    r_site   = np.array(LLH_To_ECEF(lat1, lon1, h1))
    r_uav    = np.array(LLH_To_ECEF(lat2, lon2, h2))
    rho_ecef = r_uav - r_site
    
    ECEF_2_SEZ_ROT = np.array([[sin(lat1) * cos(lon1), sin(lat1) * sin(lon1), -1 * cos(lat1)],
                               [-1 * sin(lon1)       , cos(lon1)            , 0             ],
                               [cos(lat1) * cos(lon1), cos(lat1) * sin(lon1), sin(lat1)     ]])

    rho_sez = np.dot(ECEF_2_SEZ_ROT ,rho_ecef)
    rho_mag = np.linalg.norm(rho_sez)
    el = asin(rho_sez[2]/rho_mag) * rad2deg
    az_asin = asin(rho_sez[1]/sqrt(pow(rho_sez[0],2)+pow(rho_sez[1], 2))) * rad2deg
    az_acos = acos(-1 * rho_sez[0]/sqrt(pow(rho_sez[0],2)+pow(rho_sez[1], 2))) * rad2deg
    #print az_asin, az_acos
    #Perform Quadrant Check:
    if (az_asin >= 0) and (az_acos >= 0): az = az_acos# First or Fourth Quadrant
    else: az = 360 - az_acos# Second or Third Quadrant
    #This is the Azimuth From the TARGET to the UAV
    #Must convert to Back Azimuth:
    back_az = az + 180
    if back_az >= 360:  back_az = back_az - 360
    #print az, back_az
    # rho_mag in kilometers, range to target
    # back_az in degrees, 0 to 360
    # el in degrees, negative = down tilt, positive = up tilt
    return rho_mag, az, el





